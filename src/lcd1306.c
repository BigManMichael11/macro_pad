/*
 * Copyright (c) 2019 Jan Van Winkel <jan.van_winkel@dxplore.eu>
 *
 * Based on ST7789V sample:
 * Copyright (c) 2019 Marc Reilly
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/kernel.h>

#ifndef LCD1306
#define LCD1306

#include <zephyr/logging/log.h>

#include <zephyr/device.h>
#include <zephyr/drivers/display.h>

#include "lcd1306.h"

LOG_MODULE_DECLARE(MacroPad);//KEEP THIS HERE, HAVE TO DECLARE LOGGING LEVEL


const uint8_t Arial_Narrow8x8[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char  
	0x00, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char !
	0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char "
	0xF4, 0x2F, 0xF4, 0x2F, 0x24, 0x00, 0x00, 0x00,  // Code for char #
	0x46, 0x89, 0xFF, 0x89, 0x72, 0x00, 0x00, 0x00,  // Code for char $
	0x06, 0x09, 0xC6, 0x38, 0x66, 0x91, 0x60, 0x00,  // Code for char %
	0x70, 0x96, 0x99, 0x66, 0x70, 0x00, 0x00, 0x00,  // Code for char &
	0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char '
	0x7E, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char (
	0x81, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char )
	0x0A, 0x07, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char *
	0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00,  // Code for char +
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ,
	0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char -
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char .
	0xE0, 0x18, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char /
	0x7E, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00,  // Code for char 0
	0x04, 0x02, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char 1
	0xC2, 0xA1, 0x91, 0x8E, 0x00, 0x00, 0x00, 0x00,  // Code for char 2
	0x42, 0x89, 0x89, 0x76, 0x00, 0x00, 0x00, 0x00,  // Code for char 3
	0x30, 0x2C, 0x22, 0xFF, 0x20, 0x00, 0x00, 0x00,  // Code for char 4
	0x4C, 0x8B, 0x89, 0x71, 0x00, 0x00, 0x00, 0x00,  // Code for char 5
	0x7E, 0x91, 0x89, 0x72, 0x00, 0x00, 0x00, 0x00,  // Code for char 6
	0x01, 0xE1, 0x1D, 0x03, 0x00, 0x00, 0x00, 0x00,  // Code for char 7
	0x76, 0x89, 0x89, 0x76, 0x00, 0x00, 0x00, 0x00,  // Code for char 8
	0x4E, 0x91, 0x89, 0x7E, 0x00, 0x00, 0x00, 0x00,  // Code for char 9
	0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char :
	0x80, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ;
	0x10, 0x28, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00,  // Code for char <
	0x28, 0x28, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00,  // Code for char =
	0x44, 0x28, 0x28, 0x10, 0x00, 0x00, 0x00, 0x00,  // Code for char >
	0x02, 0xB1, 0x09, 0x06, 0x00, 0x00, 0x00, 0x00,  // Code for char ?
	0x42, 0x81, 0x30, 0x4A, 0x4A, 0x7C, 0x81, 0x42,  // Code for char @
	0xC0, 0x3E, 0x21, 0x3E, 0xC0, 0x00, 0x00, 0x00,  // Code for char A
	0xFF, 0x89, 0x89, 0x89, 0x76, 0x00, 0x00, 0x00,  // Code for char B
	0x3C, 0x42, 0x81, 0x81, 0x81, 0x66, 0x00, 0x00,  // Code for char C
	0xFF, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00,  // Code for char D
	0xFF, 0x89, 0x89, 0x89, 0x89, 0x00, 0x00, 0x00,  // Code for char E
	0x00, 0xFF, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00,  // Code for char F
	0x3C, 0x42, 0x81, 0x91, 0x91, 0x76, 0x00, 0x00,  // Code for char G
	0xFF, 0x08, 0x08, 0x08, 0xFF, 0x00, 0x00, 0x00,  // Code for char H
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char I
	0x60, 0x80, 0x80, 0x7F, 0x00, 0x00, 0x00, 0x00,  // Code for char J
	0xFF, 0x08, 0x1C, 0x62, 0x81, 0x00, 0x00, 0x00,  // Code for char K
	0xFF, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,  // Code for char L
	0xFF, 0x06, 0x78, 0x80, 0x78, 0x06, 0xFF, 0x00,  // Code for char M
	0xFF, 0x02, 0x0C, 0x30, 0x40, 0xFF, 0x00, 0x00,  // Code for char N
	0x3C, 0x42, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00,  // Code for char O
	0xFF, 0x11, 0x11, 0x11, 0x0E, 0x00, 0x00, 0x00,  // Code for char P
	0x3C, 0x42, 0x81, 0xC1, 0x42, 0xBC, 0x00, 0x00,  // Code for char Q
	0x00, 0xFF, 0x09, 0x19, 0x29, 0x46, 0x80, 0x00,  // Code for char R
	0x66, 0x89, 0x89, 0x89, 0x72, 0x00, 0x00, 0x00,  // Code for char S
	0x01, 0x01, 0xFF, 0x01, 0x01, 0x00, 0x00, 0x00,  // Code for char T
	0x3F, 0x40, 0x80, 0x80, 0x40, 0x3F, 0x00, 0x00,  // Code for char U
	0x03, 0x7C, 0x80, 0x7C, 0x03, 0x00, 0x00, 0x00,  // Code for char V
	0x7F, 0x80, 0x7E, 0x01, 0x7E, 0x80, 0x7F, 0x00,  // Code for char W
	0x81, 0x66, 0x18, 0x18, 0x66, 0x81, 0x00, 0x00,  // Code for char X
	0x01, 0x06, 0xF8, 0x06, 0x01, 0x00, 0x00, 0x00,  // Code for char Y
	0xC1, 0xA1, 0x99, 0x85, 0x83, 0x00, 0x00, 0x00,  // Code for char Z
	0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char [
	0x03, 0x3C, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char BackSlash
	0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ]
	0x0E, 0x01, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ^
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char _
	0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char `
	0x64, 0x94, 0x94, 0xF8, 0x00, 0x00, 0x00, 0x00,  // Code for char a
	0xFF, 0x48, 0x84, 0x78, 0x00, 0x00, 0x00, 0x00,  // Code for char b
	0x78, 0x84, 0x84, 0x48, 0x00, 0x00, 0x00, 0x00,  // Code for char c
	0x78, 0x84, 0x48, 0xFF, 0x00, 0x00, 0x00, 0x00,  // Code for char d
	0x78, 0x94, 0x94, 0x58, 0x00, 0x00, 0x00, 0x00,  // Code for char e
	0xFF, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char f
	0x78, 0x84, 0x48, 0xFC, 0x00, 0x00, 0x00, 0x00,  // Code for char g
	0xFF, 0x08, 0x04, 0xF8, 0x00, 0x00, 0x00, 0x00,  // Code for char h
	0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char i
	0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char j
	0xFF, 0x10, 0x28, 0xC4, 0x00, 0x00, 0x00, 0x00,  // Code for char k
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char l
	0xFC, 0x08, 0x04, 0xF8, 0x08, 0x04, 0xFC, 0x00,  // Code for char m
	0xFC, 0x08, 0x04, 0xF8, 0x00, 0x00, 0x00, 0x00,  // Code for char n
	0x78, 0x84, 0x84, 0x78, 0x00, 0x00, 0x00, 0x00,  // Code for char o
	0xFC, 0x48, 0x84, 0x78, 0x00, 0x00, 0x00, 0x00,  // Code for char p
	0x78, 0x84, 0x48, 0xFC, 0x00, 0x00, 0x00, 0x00,  // Code for char q
	0xFC, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char r
	0x4C, 0x94, 0xA4, 0x48, 0x00, 0x00, 0x00, 0x00,  // Code for char s
	0xFF, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char t
	0x7C, 0x80, 0x40, 0xFC, 0x00, 0x00, 0x00, 0x00,  // Code for char u
	0x0C, 0x70, 0x80, 0x70, 0x0C, 0x00, 0x00, 0x00,  // Code for char v
	0x7C, 0x80, 0x78, 0x04, 0x78, 0x80, 0x7C, 0x00,  // Code for char w
	0x84, 0x48, 0x30, 0x48, 0x84, 0x00, 0x00, 0x00,  // Code for char x
	0x04, 0x38, 0xC0, 0x38, 0x04, 0x00, 0x00, 0x00,  // Code for char y
	0xC4, 0xA4, 0x94, 0x8C, 0x00, 0x00, 0x00, 0x00,  // Code for char z
	0x18, 0xE7, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char {
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char |
	0x81, 0xE7, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char }
	0x00, 0x10, 0x08, 0x18, 0x10, 0x08, 0x00, 0x00,  // Code for char ~
	0xFF, 0x81, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00   // Code for char 
};


#define char_w 8
#define char_h 8

const struct device *display_dev;


uint8_t *buf_empty;
struct display_buffer_descriptor empty_buf;
uint16_t empty_buf_size = 128*4*(sizeof(uint8_t));

uint8_t *all_char_buf;	
struct display_buffer_descriptor font_desc;



int clear_screen(){
	return display_write(display_dev,0,0,&empty_buf,buf_empty);
}


int print_char( const uint8_t col, const uint8_t row, const uint8_t c){
	return display_write(display_dev, col, row, &font_desc, &Arial_Narrow8x8[(c-32)*8]);
}

int print_str(const uint8_t col, const uint8_t row, const char *str, const uint8_t length){
	int r;
    for (int i = 0; i < length; i++){
		 r = print_char(col * char_w + i*char_w, row, str[i]);
        if(r != 0){
            //LOG_ERR("               FAILED TO WRITE CHAR %c", str[i]);
            return r;
        } else if(r == length - 1){
            return r;
        }
    }
    return r;
}






uint8_t lcd1306_init(){
    struct display_capabilities capabilities;

    
	display_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_display));
	if (!device_is_ready(display_dev)) {
		//LOG_ERR("Device %s not found. Aborting sample.", display_dev->name);
	}

    //LOG_INF("Display sample for %s", display_dev->name);
	display_get_capabilities(display_dev, &capabilities);



    empty_buf.buf_size = empty_buf_size;
	empty_buf.pitch = 128;//capabilities.x_resolution;
	empty_buf.width = 128;
	empty_buf.height = 32;


    font_desc.buf_size = char_w*char_h*sizeof(uint8_t);
	font_desc.pitch = char_w;//capabilities.x_resolution;
	font_desc.width = char_w;
	font_desc.height = char_h;


    
    buf_empty = k_malloc(128*4*sizeof(uint8_t));

    memset(buf_empty, 0, 128*4);

    int r = display_write(display_dev,0,0,&empty_buf,buf_empty);
    //LOG_INF("Display cleared");

    print_str(0, 0, "Hello World! ", 12);
    LOG_INF("Hello world written");


    return r;
}



#ifdef NEVER
int main(void)
{

	all_char_buf = k_malloc((127-32)*char_w*char_h*sizeof(uint8_t));

	size_t buf_size;
	struct display_buffer_descriptor empty_buf;
	struct display_capabilities capabilities;

	const struct device *display_dev;
	display_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_display));
	if (!device_is_ready(display_dev)) {
		LOG_ERR("Device %s not found. Aborting sample.", display_dev->name);
	}

	LOG_INF("Display sample for %s", display_dev->name);
	display_get_capabilities(display_dev, &capabilities);


	buf_size = 128*32*sizeof(uint8_t);

	empty_buf.buf_size = buf_size;
	empty_buf.pitch = 128;//capabilities.x_resolution;
	empty_buf.width = 128;
	empty_buf.height = 32;


	

	uint8_t *buf_empty;

	buf_empty = k_malloc(128*4*sizeof(uint8_t));
	

	memset(buf_empty, 0, 128*4);//128*32*sizeof(uint8_t));

/*
	const unsigned short yippe[] = {0x00, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x00, 0x00};
	for(int i = 0; i < 32; i++){
		for (int j = 0; j < 128; j++){
			buf_all[i*128+j] = 0x0u;//0xFFu;//(j % 2) * 0xFFu;
			if((i < 8) && (j < 8)){
				buf_all[i*128 + j] = ((yippe[j] & (1 << i)) >> i) * 0xFFu;
				k_msleep(5);
				//LOG_INF("i: %d j: %d val:%d",i, j, buf_all[i*128 + j]);
			}
		}
	}
*/
	
	font_desc.buf_size = char_w*char_h*sizeof(uint8_t);
	font_desc.pitch = char_w;//capabilities.x_resolution;
	font_desc.width = char_w;
	font_desc.height = char_h;



	display_write(display_dev,0,0,&empty_buf,buf_empty);

	int x = 0;
	int y = 0;

	bool lastWritten = 1;
	while (1) {
		//memset(buf, grey_count, buf_size);
		//display_write(display_dev, x, y, &empty_buf, lastWritten? buf : buf2);
		//display_write(display_dev, 0, 0, &empty_buf, buf_all);
		
		//print_char(display_dev, x, y, 'O');
		print_str(display_dev, x, y, "Hello World! ", 12);
		y = (y+16)%32;

		k_msleep(50);
	}
	return 0;
}
#endif



#endif